oleg mazonka , '' bit copying : the ultimate computational simplicity '' , complex systems journal 2011 , vol 19 , n3 , pp 263–285 currently known oiscs can be roughly separated into three broad categories : bit-manipulating machines transport triggered architecture machines arithmetic-based turing-complete machines , an sbn oisc , the subleq language , etc subtract and branch if not equal to zero the instruction ( '' subtract and branch if less than or equal to zero '' ) subtracts the contents at address from the contents at address , stores the result at address , and then , if the result is not positive , transfers control to address ( if the result is positive , execution proceeds to the next instruction in sequence ) if the third operand is not written , this suppression is implied the result is stored in both the accumulator and the memory location , and the second operand specifies the branch address : subleq2 a , b ; mema mema - accum ; accum mema ; if ( mema ≤ 0 ) goto b although this uses only two ( instead of three ) operands per instruction , correspondingly more instructions are then needed to effect various logical operations , the following instructions result in the content at location getting replaced by the content at location , again assuming the content at location is maintained as 0 : ; : subleq b , b subleq a , z subleq z , b subleq z , z any desired arithmetic test can be built for example , a branch-if-zero condition can be assembled from the following instructions : ; : subleq b , z , l1 subleq z , z , out l1 : subleq z , z subleq z , b , c out : similar interpreters written in a -based language ( i.e , self-interpreters , which may use self-modifying code as allowed by the nature of the instruction ) can be found in the external links below it is possible to synthesize many types of higher-order instructions using only the instruction subneg4 s , m , r , j ; subtrahend , minuend , result and jump addresses ; memr memm - mems ; if ( memr he mentions that it can easily be shown using the elements of recursive functions that every number calculable on the arithmetic machine is computable a proof of which was given by lambek on an equivalent two instruction machine : x+ ( increment x ) and x− else t ( decrement x if it not empty , else jump to t ) reverse subtract and skip if borrow the result is stored in both the accumulator and the memory location this instruction moves the contents of one memory location to another memory location combining with the current content of the new location : move a to b ; memb : mema ( + , - , , / , so memory cells are not simple store but coupled with an arithmetic logic unit ( alu ) setup to perform only one sort of operation with the current value of the cell