that is , unlike low-level languages like assembly or machine language , high-level programming can amplify the programmer 's instructions and trigger a lot of data movements in the background without their knowledge the responsibility and power of executing instructions have been handed over to the machine from the programmer however , with the growing complexity of modern microprocessor architectures , well-designed compilers for high-level languages frequently produce code comparable in efficiency to what most low-level programmers can produce by hand , and the higher abstraction may allow for more powerful techniques providing better overall results than their low-level counterparts in particular settings this is the engineering 'trade-off ' for the 'abstraction penalty ' ) , basically supports only scalar operations , and provides direct memory addressing : ; intermediate representations : when code written in a language is compiled to an intermediate representation , that representation can be optimized or saved for later execution without the need to re-read the source file virtual machines that execute bytecode directly or transform it further into machine code have blurred the once clear distinction between intermediate representations and truly compiled languages ; source-to-source translated or transcompiled : code written in a language may be translated into terms of a lower-level language for which native code compilers are already common specifically , the generated c and c++ code can be seen ( as generated from the eiffel language when using the eiffelstudio ide ) in the eifgens directory of any compiled eiffel project this is known as a high-level language computer architecture â€“ the computer architecture itself is designed to be targeted by a specific high-level language