the following conditions are necessary to achieve cache coherence : in a read made by a processor p to a location x that follows a write by the same processor p to x , with no writes to x by another processor occurring between the write and the read instructions made by p , x must always return the value written by p p4 on the other hand may see changes made by p1 and p2 in the order in which they are made and hence return 20 on a read to s neupane , mahesh ( april 16 , 2004 ) the alternative definition of a coherent system is via the definition of sequential consistency memory model : '' the cache coherent system must appear to execute all threads â€™ loads and stores to a single memory location in a total order that respects the program order of each thread '' rarely , but especially in algorithms , coherence can instead refer to the locality of reference '' design of a snoop filter for snoop-based cache coherency protocols '' ( pdf ) the directory acts as a filter through which the processor must ask permission to load an entry from the primary memory to its cache the protocol must implement the basic requirements for coherence typically , early systems used directory-based protocols where a directory would keep a track of the data being shared and the sharers all processors snoop the request and respond appropriately write propagation in snoopy protocols can be implemented by either of the following methods : ; write-invalidate : when a write operation is observed to a location that a cache has a copy of , the cache controller invalidates its own copy of the snooped memory location , which forces a read from main memory of the new value on its next access various models and protocols have been devised for maintaining coherence , such as msi , mesi ( aka illinois ) , mosi , moesi , mersi , mesif , write-once , synapse , berkeley , firefly and dragon protocol consistency model directory-based coherence memory barrier non-uniform memory access ( numa ) false sharing