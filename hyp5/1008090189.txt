tightly coupled objects can be hard to implement in some scenarios , and hard to reuse because they refer to and know about ( and how to update ) many different objects with different interfaces the responsibility of observers is to register ( and unregister ) themselves on a subject ( to get notified of state changes ) and to update their state ( synchronize their state with the subject 's state ) when they are notified subject and observers have no explicit knowledge of each other observers can be added and removed independently at run-time see also the uml class and sequence diagram below the observer pattern can cause memory leaks , known as the lapsed listener problem , because in a basic implementation , it requires both explicit registration and explicit deregistration , as in the dispose pattern , because the subject holds strong references to the observers , keeping them alive coupling and typical pub-sub implementations other implementations of the publish-subscribe pattern , which achieve a similar effect of notification and communication to interested parties , do not use the observer pattern at all comparison between different observer pattern implementations moshe bindler , 2015 ( github ) differences between pub/sub and observer pattern the observer pattern by adi osmani ( safari books online ) in early implementations of multi-window operating systems like os/2 and windows , the terms '' publish-subscribe pattern '' and '' event driven software development '' were used as a synonym for the observer pattern below is an example written in java that takes keyboard input and treats each input line as an event